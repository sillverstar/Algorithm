# 미로 탈출 문제(BFS) 단계별 흐름 정리📄

<br>

## 1. 입력

```0번째 입력
5 6
101010
111111
000001
111111
111111
```

<br>

## 2. BFS 단계별 출력



```
# 0번째 while문

# deque([(1, 0)])

# graph
1 0 1 0 1 0
2 1 1 1 1 1
0 0 0 0 0 1
1 1 1 1 1 1
1 1 1 1 1 1
```

```
# 1번째 while문

# deque([(0, 0), (1, 1)])

# graph
3 0 1 0 1 0
2 3 1 1 1 1
0 0 0 0 0 1
1 1 1 1 1 1
1 1 1 1 1 1
```


- 첫 번째 시작 위치가 3으로 변경됨.<br>(but, 문제 자체가 단순히 가장 오른쪽 아래 위치로 이동하는 것을 요구하기 때문에 결과값에 영향을 끼치지 않음)
<br>


```
# 2번째 while문

# deque([(1, 1)])

# graph
3 0 1 0 1 0
2 3 1 1 1 1
0 0 0 0 0 1
1 1 1 1 1 1
1 1 1 1 1 1
```



```
# 3번째 while문

# deque([(1, 2)])

# graph
3 0 1 0 1 0
2 3 4 1 1 1
0 0 0 0 0 1
1 1 1 1 1 1
1 1 1 1 1 1
```


```
# 4번째 while문

# deque([(0, 2), (1, 3)])

# graph
3 0 5 0 1 0
2 3 4 5 1 1
0 0 0 0 0 1
1 1 1 1 1 1
1 1 1 1 1 1
```
- 이전(3번째 while문)에 들어있던 (1, 2) = 4에 대한 while문 결과.<br>
  '상 -> 하 -> 좌 -> 우' 순서로 탐색하므로 큐에 (0, 2)가 먼저 들어옴.
<br>

```
# 5번째 while문

# deque([(1, 3)])

# graph
3 0 5 0 1 0
2 3 4 5 1 1
0 0 0 0 0 1
1 1 1 1 1 1
1 1 1 1 1 1
```
- (0, 2)에 대한 while문 결과. 주변에 1인 값이 없어서 변화 X
<br>


```
# 6번째 while문

# deque([(1, 4)])

# graph
3 0 5 0 1 0
2 3 4 5 6 1
0 0 0 0 0 1
1 1 1 1 1 1
1 1 1 1 1 1
```

```
# 7번째 while문

# deque([(0, 4), (1, 5)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 1
1 1 1 1 1 1
1 1 1 1 1 1
```

```
# 8번째 while문

# deque([(1, 5)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 1
1 1 1 1 1 1
1 1 1 1 1 1
```

```
# 9번째 while문

# deque([(2, 5)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 8
1 1 1 1 1 1
1 1 1 1 1 1
```

```
# 10번째 while문

# deque([(3, 5)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 8
1 1 1 1 1 9
1 1 1 1 1 1
```

```
# 11번째 while문

# deque([(4, 5), (3, 4)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 8
1 1 1 1 10 9
1 1 1 1 1 10
```

- 이전(10번째 while문)에 들어있던 (3, 5) = 9에 대한 while문 결과.
- 이제 아래 while문들은 남은 1을 처리하는 부분. 의미 X
<br>

```
# 12번째 while문

# deque([(3, 4), (4, 4)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 8
1 1 1 1 10 9
1 1 1 1 11 10
```

```
# 13번째 while문

# deque([(4, 4), (3, 3)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 8
1 1 1 11 10 9
1 1 1 1 11 10
```

```
# 14번째 while문

# deque([(3, 3), (4, 3)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 8
1 1 1 11 10 9
1 1 1 12 11 10
```

```
# 15번째 while문

# deque([(4, 3), (3, 2)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 8
1 1 12 11 10 9
1 1 1 12 11 10
```

```
# 16번째 while문

# deque([(3, 2), (4, 2)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 8
1 1 12 11 10 9
1 1 13 12 11 10
```

```
# 17번째 while문

# deque([(4, 2), (3, 1)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 8
1 13 12 11 10 9
1 1 13 12 11 10
```

```
# 18번째 while문

# deque([(3, 1), (4, 1)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 8
1 13 12 11 10 9
1 14 13 12 11 10
```

```
# 19번째 while문

# deque([(4, 1), (3, 0)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 8
14 13 12 11 10 9
1 14 13 12 11 10
```

```
# 20번째 while문

# deque([(3, 0), (4, 0)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 8
14 13 12 11 10 9
15 14 13 12 11 10
```

```
# 21번째 while문

# deque([(4, 0)])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 8
14 13 12 11 10 9
15 14 13 12 11 10
```

```
# 22번째 while문

# deque([])

# graph
3 0 5 0 7 0
2 3 4 5 6 7
0 0 0 0 0 8
14 13 12 11 10 9
15 14 13 12 11 10
```



## 3. 결과

```결과(result)
10
```
